# 华南理工大学
## 《网络应用开发》课程实验报告

实验题目： 设计并实现一个电子商务网站的开发和在线部署
姓名： 崔少旭
学号： 202330452691
班级： 计算机科学与技术2班
提交日期： 2025-12-30
代码托管地址： https://github.com/Cui-SX/-
部署在线网站： http://8.148.200.220:8080/e-commerce
测试账号口令：
管理员/销售经理：用户名 `sales` / 密码 `sales123`
普通顾客：用户名 `test` / 密码 `123456` (或自行注册)

---

### 实验概述

【实验题目】
设计并实现一个电子商务网站的开发和在线部署。

【基本功能要求】
本实验旨在构建一个功能完备的 B2C 电商平台，涵盖前台顾客交易系统和后台管理系统。
1.  顾客端功能：
    用户账户体系：支持用户注册、登录（Session维持）、注销及个人信息修改。
    商品浏览：支持商品列表展示、关键词搜索、按分类筛选、商品详情查看。
    购物车系统：支持商品添加、数量调整、移除商品、购物车总价实时计算。
    订单流程：完整的下单流程（确认地址 -> 生成订单 -> 模拟支付 -> 邮件确认），支持查看历史订单状态（待支付、已完成等）。
2.  销售/管理端功能：
    商品管理：支持商品的上架（新增）、下架（删除）、信息修改（价格、库存、图片）。
    订单管理：管理员可查看所有用户订单，并修改订单状态（如发货、取消）。
    数据统计：提供可视化的销售报表，展示订单总数、销售总额及各状态订单分布。
    权限控制：区分普通用户、管理员和销售经理的权限，防止越权访问。

【实验环境和工具】
开发环境：Windows 11, Visual Studio Code
服务器环境：阿里云 ECS (Ubuntu 22.04 LTS, 2核 2G)
JDK版本：OpenJDK 8
Web容器：Apache Tomcat 9.0.98
数据库：MySQL 8.0.35
构建工具：Apache Maven 3.8
版本控制：Git
前端技术：JSP, JSTL, EL表达式, CSS3 (Flexbox布局)

---

### 实验内容

#### 1. 系统设计

1.1 系统架构设计
本系统严格遵循 MVC (Model-View-Controller) 设计模式，实现了业务逻辑、数据模型与用户界面的解耦，确保系统的可维护性和扩展性。

View (视图层)：
    位于 `src/main/webapp` 目录。
    使用 JSP (JavaServer Pages) 进行页面渲染。
    广泛使用 JSTL (JSP Standard Tag Library) 和 EL (Expression Language) 替代 Java 脚本代码，保持页面整洁。
    包含公共组件：`header.jsp` (导航栏), `footer.jsp` (页脚)。
Controller (控制层)：
    位于 `src/main/java/com/ecommerce/servlet` 目录。
    由多个 Servlet 组成（如 `AuthServlet`, `ProductServlet`, `OrderServlet`）。
    负责接收 HTTP 请求，解析参数，调用 DAO 层处理业务，并将结果存入 Request/Session 域，最后转发 (`forward`) 或重定向 (`redirect`) 到视图层。
Model (模型层)：
    Entity (实体类)：`User`, `Product`, `Order`, `OrderItem`，对应数据库表结构。
    DAO (数据访问对象)：`UserDAO`, `ProductDAO`, `OrderDAO`，封装所有 JDBC 操作，实现数据的持久化。
    Util (工具类)：`DBUtil` (数据库连接池), `EmailUtil` (邮件发送)。

1.2 数据库设计 (Schema)
系统数据库名为 `ecommerce`，包含以下核心数据表：

1.  `users` (用户表)
    `id`: 主键，自增。
    `username`: 用户名，唯一索引。
    `password`: 密码（生产环境应加密存储，本实验为演示明文存储）。
    `role`: 枚举类型 (`customer`, `admin`, `sales_manager`)，用于权限控制。
2.  `products` (商品表)
    `id`: 主键。
    `name`, `description`, `price`, `stock`: 商品基本信息。
    `image_url`: 图片路径（支持本地相对路径 `pictures/xxx.jpg`）。
3.  `orders` (订单主表)
    `id`: 主键。
    `user_id`: 外键，关联用户。
    `total_amount`: 订单总金额。
    `status`: 订单状态 (`pending`, `completed`, `shipped`, `cancelled`)。
4.  `order_items` (订单明细表)
    `order_id`: 外键，关联订单。
    `product_id`: 外键，关联商品。
    `quantity`, `price`: 购买时的数量和单价（快照数据）。

#### 2. 代码实现

2.1 数据库连接管理 (DBUtil.java)
为了提高性能和安全性，封装了数据库连接逻辑，并支持从配置文件读取参数。

```java
public class DBUtil {
    // 静态代码块加载驱动，确保只加载一次
    static {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            // 加载 config.properties 配置文件
            InputStream in = DBUtil.class.getClassLoader().getResourceAsStream("config.properties");
            props.load(in);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static Connection getConnection() throws SQLException {
        // 获取连接，支持 URL 参数配置（如 useSSL, serverTimezone）
        return DriverManager.getConnection(props.getProperty("db.url"),
                props.getProperty("db.username"), 
                props.getProperty("db.password"));
    }
}
```

2.2 订单支付与状态流转 (OrderServlet.java)
这是系统的核心业务逻辑，涉及权限验证、状态更新和邮件通知。

```java
private void handlePayOrder(HttpServletRequest request, HttpServletResponse response, User user) 
        throws ServletException, IOException {
    int orderId = Integer.parseInt(request.getParameter("orderId"));
    Order order = orderDAO.getOrderById(orderId);
    
    // 安全性检查：确保订单存在，且属于当前登录用户
    if (order != null && order.getUserId() == user.getId() && "pending".equals(order.getStatus())) {
        // 1. 更新数据库状态
        if (orderDAO.updateOrderStatus(orderId, "completed")) {
            // 2. 发送确认邮件 (异步或同步)
            EmailUtil.sendOrderConfirmation(user.getEmail(), user.getFullName(), orderId, order.getTotalAmount());
            // 3. 跳转到详情页并提示成功
            response.sendRedirect("order?action=detail&id=" + orderId + "&message=Payment successful!");
        } else {
            response.sendRedirect("order?action=detail&id=" + orderId + "&error=Payment failed.");
        }
    }
}
```

2.3 销售统计报表 (AdminServlet.java)
后台管理模块通过聚合函数实现数据统计。

```java
// AdminServlet 处理 /stats 请求
private void handleStats(HttpServletRequest request, HttpServletResponse response) {
    // 调用 DAO 获取统计数据 Map
    Map<String, Object> stats = orderDAO.getSalesStatistics();
    request.setAttribute("stats", stats);
    // 转发到 JSP 进行渲染
    request.getRequestDispatcher("/WEB-INF/admin/salesStats.jsp").forward(request, response);
}

// OrderDAO 中的 SQL 实现
public Map<String, Object> getSalesStatistics() {
    // 统计总订单数
    String countSql = "SELECT COUNT(*) as total FROM orders";
    // 统计总销售额 (排除已取消订单)
    String revenueSql = "SELECT SUM(total_amount) as revenue FROM orders WHERE status != 'cancelled'";
    // ...执行查询并封装结果...
}
```

#### 3. 功能测试

3.1 测试环境
客户端：Google Chrome 浏览器 (版本 120.0)
服务器：阿里云 ECS 远程部署环境

3.2 测试用例与结果

| 测试模块 | 测试场景 | 预期结果 | 实际结果 | 结论 |
| :--- | :--- | :--- | :--- | :--- |
| 用户模块 | 用户注册 | 输入未注册的用户名和邮箱，提交表单 | 数据库新增记录，跳转至登录页 | 通过 |
| 用户模块 | 权限拦截 | 未登录状态下直接访问 `/cart` 或 `/admin` | 系统自动重定向至 `/login.jsp` | 通过 |
| 商品模块 | 图片展示 | 访问商品列表页 | 所有商品图片正常加载，无裂图 | 通过 |
| 交易模块 | 下单支付 | 将商品加入购物车，结算并点击“立即支付” | 订单状态变为“已完成”，库存扣减 | 通过 |
| 管理模块 | 销售报表 | 管理员访问“销售报表”页面 | 正确显示订单总数和销售总额 | 通过 |
| 管理模块 | 路径兼容 | 访问 `/admin/stats` 和 `/admin/salesStats.jsp` | 均能正确显示报表，无 404 或白屏 | 通过 |

3.3 测试截图
(此处请插入实验过程中截取的图片：如商品列表页、订单详情页、后台统计报表页等)

#### 4. 应用部署

4.1 部署策略
为了适应云服务器环境并简化部署流程，本实验放弃了传统的手动配置方式，采用了全自动化 Shell 脚本部署方案。

4.2 部署脚本 (`deploy.sh`) 解析
脚本实现了“一键部署”，主要包含以下步骤：
1.  环境初始化：使用 `apt-get` 自动安装 OpenJDK 8, Tomcat 9 和 MySQL Server。
2.  数据库配置：
    使用 `mysql -e` 命令非交互式地修改 root 密码。
    自动导入 `schema.sql` 初始化表结构和预设数据。
3.  应用发布：
    清理 Tomcat `webapps` 目录下的旧版本。
    将 `e-commerce.war` 移动到部署目录。
4.  动态配置：
    脚本会监控 Tomcat 的解压进度。
    一旦解压完成，使用 `sed` 命令修改 `config.properties` 中的数据库密码，确保生产环境连接正常。

4.3 部署操作记录
在阿里云 Workbench 终端执行以下命令完成部署：
```bash
cd ~
unzip -o deploy.zip       # 解压部署包
cd deploy
chmod +x deploy.sh        # 赋予执行权限
./deploy.sh               # 执行部署
```
脚本运行约 2 分钟后，提示 "Deployment Completed"，服务成功上线。

---

### 小结

使用AI辅助完成本课程实验的心得体会

本次实验是我首次尝试在大规模 Web 开发中深度结合生成式 AI 工具（GitHub Copilot / Gemini）。这一过程不仅极大地提升了开发效率，更让我在解决复杂技术问题时有了全新的思路。

1.  从“代码编写者”到“系统设计者”的转变：
    在 AI 的辅助下，我不再需要花费大量时间去记忆 JDBC 的繁琐语法或 CSS 的具体属性。我将精力更多地集中在系统架构的设计上，例如如何设计数据库表关联、如何划分 Servlet 的职责边界。AI 能够根据我的设计意图快速生成样板代码，让我能像搭积木一样快速构建系统原型。

2.  复杂问题的排查与解决：
    实验过程中遇到了几个棘手的问题，AI 在排查中起到了关键作用：
    数据库权限问题：在初始化数据时，由于 `schema.sql` 中定义了 `sales_manager` 角色，但数据库表定义未及时更新，导致导入失败。AI 敏锐地指出了 `ENUM` 类型定义不匹配的问题，并给出了 `ALTER TABLE` 修正语句。
    Servlet 路径映射陷阱：在部署后，后台报表页面出现白屏。通过分析 Tomcat 日志，发现是前端链接指向了 `.jsp` 文件，而 Servlet 监听的是无后缀路径。AI 不仅解释了 Servlet 容器的匹配规则，还协助我修改了 `AdminServlet` 以兼容多种路径访问，彻底解决了问题。
    自动化部署脚本：编写一个健壮的 Shell 脚本对初学者很难。我通过向 AI 描述服务器环境（Ubuntu）和需求（自动安装软件、修改配置），AI 生成了包含错误处理和等待逻辑的 `deploy.sh`，这让我深刻体会到了自动化运维的魅力。

3.  局限性与反思：
    虽然 AI 强大，但它并非万能。例如在处理图片资源时，AI 建议使用外部图床，导致国内访问受限。这让我意识到，开发者必须具备 Code Review 的能力，不能盲目信任 AI 的输出，必须结合实际网络环境和业务场景进行判断。

4.  展望：
    通过本次实验，我深刻认识到，未来的软件开发将是“人机协作”的模式。掌握 AI 工具的使用，不仅能提高效率，更能帮助我们跨越技术栈的门槛，快速实现创意。在未来的学习中，我将继续探索如何更精准地使用提示词（Prompt Engineering），并加强对底层原理的理解，以更好地驾驭 AI 工具。

---

指导教师评语及成绩

评语：

成绩： __________ 指导教师签名： __________ 批阅日期： __________
